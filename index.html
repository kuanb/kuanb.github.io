---
layout: default
---

<div class="home">

  <div id="whowhatwhere" class="whowhatwhere">
    <img src="/images/me.jpeg" alt="Kuan Butts" class="avatar"/>
    <span class="h3" style="text-shadow: 0 0 10px #FFF;">
      who, what, where
    </span>

    <div id="worldContainer" style="height: 350px; width: 100%; margin-top: -100px">
      <canvas id='world' style="height: 100%; width: 100%;"></canvas>
    </div>

    <div class="blurb">
      <div class='splash'>
        Kuan is a transportation systems researcher and software developer, currently at Mapbox.
      </div>
      
      <ul>
        <li>
          <div class='splash' style="padding-left:10px;">
            
            <p class='smallp'>
              <small><i class="fa fa-map-pin" aria-hidden="true"></i></small>
              Sr. Software Engineer on <a href="http://www.mapbox.com/telemetry/">Telemetry</a> at <a href="http://www.mapbox.com/">Mapbox</a> in San Francisco, California ('19 - present).
            </p>

            <p class='smallp'>
              <small><i class="fa fa-map-pin" aria-hidden="true"></i></small>
              Data science & engineering; specializing in transit and mobility at <a href="http://urbanfootprint.com/">UrbanFootprint</a> in Berkeley, California ('17 - '19).
            </p>
            
            <p class='smallp'>
              <small><i class="fa fa-map-pin" aria-hidden="true"></i></small>
              <a href="http://www.codeforamerica.org/people/kuan-butts">2016 Fellow</a> software engineer at <a href="http://www.codeforamerica.org/">Code for America</a>, on <a href="http://c4a-slc.tumblr.com/">Team Salt Lake County</a>.
            </p>
            
            <p class='smallp'>
              <small><i class="fa fa-map-pin" aria-hidden="true"></i></small>
              2015 Civic Tech Fellow at <a href="http://microsoftnewyork.com/">Microsoft</a> in New York City, where I developed performance data tools on top of MTA's One-Bus-Away implementation. 
            </p>
            
            <p class='smallp'>
              <small><i class="fa fa-map-pin" aria-hidden="true"></i></small>
              Former researcer and developer working on scenario modeling software with the <a href="http://www.media.mit.edu/research/groups/changing-places">MIT Media Lab</a> and <a href="https://mfc.mit.edu/">Flocktracker</a> - a transit network mapping tool - with the <a href="http://smart.mit.edu/research/future-urban-mobility/future-urban-mobility.html">Singapore-MIT Alliance for Research and Technology</a> during and after graduate studies at <a href="http://web.mit.edu/">MIT</a> ('12 - '15).
            </p>
          
          </div>
        </li>
      </ul>
    </div>

    <div class="strong-btn">
      <h4>
        Select posts from <a href="http://kuanbutts.com/blog/">blog</a>
      </h4>
      <div class="blog-post">
        <a href="2018/11/19/graph-tool-drive-network-stress-test/">Modeling critical infrastructure shutdowns</a>
      </div>
      <div class="blog-post">
        <a href="2018/11/09/meshgrids/">Rapid, matrix-based spatial analysis</a>
      </div>
      <div class="blog-post">
        <a href="2018/08/17/peartree-to-graph-tool/">High performance peartree network analysis (2-part Series)</a>
      </div>
      <div class="blog-post">
        <a href="2018/07/14/graph-app-concept/">Transit Network Sketch Analysis Interface Prototype</a>
      </div>
      <div class="blog-post">
        <a href="2018/05/25/comparing-6-18-buses/">Corridor analysis with GTFS-RT trace data</a>
      </div>
      <div class="blog-post">
        <a href="2017/12/16/osmnx-isochrones/">Better rendering of accessibility isochrones from network graphs</a>
      </div>
      <div class="blog-post">
        <a href="2017/12/02/sd-midcoast-access-2/">Opportunity costing via network accessibility: MidCoast Trolley alignment scenarios comparison</a>
      </div>
      <div class="blog-post">
        <a href="2017/10/21/spectral-cluster-berkeley/">Identifying urban zones with spectral clustering</a>
      </div>
      <div class="blog-post">
        <a href="2017/08/17/delaunay-triangulation/">Abstracting Complex Geometries as Points</a>
      </div>
    </div>
  </div>
  
</div>


<script type="text/javascript">
  // ----------------------------------------------
  // Generative road network rendering script below
  // ----------------------------------------------

  var metas = document.getElementsByTagName('meta');
  var i;

  // Update context canvas if vertical screen
  var check1 = window.innerHeight > window.innerWidth;
  var check2 = window.innerWidth <= 600;
  var check12 = check1 && check2;
  if (check12) {
    var newHeight = window.innerWidth * .5;
    document.getElementById("worldContainer").style.height = `${newHeight}px`;
  }

  // Update context canvas
  var width = document.getElementById('world').width * 2;
  var height = document.getElementById('world').height * 3;

  var oneDegree = Math.PI / 180;
  var borderDrawDropWidth = 15;
  var shouldCreateSpurOdds = 0.5;

  var Agent = function (path) {
    this.path = path;
    this.increment = 1;
    this.finished = false;

    this.updateDrawnPath = function () {
      var i = this.increment;

      if (this.finished) {
        return;

      } else if (this.path[i]) {
        var a = this.path[i - 1];
        var b = this.path[i];

        context.strokeStyle = 'rgba(0, 51, 102, 0.1)';
        context.beginPath();

        context.moveTo(a[0], a[1]);
        context.lineTo(b[0], b[1]);

        context.lineWidth = 1;
        context.stroke();

        context.fillStyle = 'rgba(0, 51, 102, 0.05)';
        context.beginPath();
        var radius = Math.random() * 2;
        context.arc(b[0], b[1], radius, 0, (2 * Math.PI));
        context.fill();

        this.increment += 1;

      } else {
        this.finished = true;

        var last = this.path[this.path.length - 1]
        var lastX = last[0];
        var lastY = last[1];

        context.fillStyle = 'rgba(0, 51, 102, 0.05)';
        context.beginPath();
        var radius = Math.random() * 3 + 1;
        context.arc(lastX, lastY, radius, 0, (2 * Math.PI));
        context.fill();
      }
    }
  };

  var Boid = function (x, y, angle, breadCrumbs) {
      this.x = x;
      this.y = y;
      this.angle = angle;

      this.breadCrumbs = [];
      if (breadCrumbs && breadCrumbs.length) {
        this.breadCrumbs = this.breadCrumbs.concat(breadCrumbs);
      }
      this.breadCrumbs = this.breadCrumbs.concat([x,y]);

      this.lifeFactor = Math.random();
      this.lifeLeft = Math.ceil((this.lifeFactor * 100)) + 10;

      this.projectedAge = this.lifeLeft;
      this.dead = false;

      this.update = function () {
        var oldX = this.x;
        var oldY = this.y;

        // Odds of turning decrease as path is longer
        var oddsOfHardTurn = shouldCreateSpurOdds;


        if (runGreaterThanOdds(0.5)) {
          if (runGreaterThanOdds(0.5)) {
            this.angle = this.angle + (Math.PI / 12);
          } else {
            this.angle = this.angle - (Math.PI / 12);
          }
        } else if (runGreaterThanOdds(0.8)) {
          if (runGreaterThanOdds(0.5)) {
            this.angle = this.angle + (Math.PI / 2);
          } else {
            this.angle = this.angle - (Math.PI / 2);
          }
        }

        var dx = Math.cos(this.angle);
        var dy = Math.sin(this.angle);

        var dist = 3;
        this.x += dx * dist;
        this.y += dy * dist;
        this.lifeLeft -= 1;

        var newX = this.x;
        var newY = this.y;

        this.breadCrumbs.push([newX, newY]);

        // if it hit some other path, kill
        var xFloorAdj = Math.floor(this.x);
        var yFloorAdj = width * Math.floor(this.y);
        var index = (xFloorAdj + yFloorAdj) * 4;
        if (data[index + 3] > 0) this.kill();

        // Kill if lifespan reached
        if (this.lifeLeft <= 0) this.kill();

        // Remove if being drawn off screen
        var tempSensitivity = Math.random() * borderDrawDropWidth;
        if (this.x < tempSensitivity || this.x > width - tempSensitivity) this.kill();
        if (this.y < tempSensitivity || this.y > height - tempSensitivity) this.kill();

        // fade out around the corners so it is not too boxy
        var distCenterX = Math.abs(this.x - (width/2));
        var distCenterY = Math.abs(this.y - (height/2))
        var distCenter = Math.sqrt((distCenterX * distCenterX) + (distCenterY * distCenterY));
        if (distCenter > (width/2*(Math.random()*.4 + .6))) this.kill();

      };

      this.drawLastPath = function () {

        var bcl = this.breadCrumbs.length;
        if (bcl > 1) {

          context.strokeStyle = 'rgba(173,216,230,0.75)';
          context.beginPath();

          var s1 = this.breadCrumbs[bcl - 2];
          context.moveTo(s1[0], s1[1]);

          var segment = this.breadCrumbs[bcl - 1];
          var nextX = segment[0];
          var nextY = segment[1];

          context.lineTo(nextX, nextY);

          context.lineWidth = 0.5;
          context.stroke();
        }

      }

      this.kill = function () {
        this.dead = true;

        // Remove from reference list
        var removed = boids.splice(boids.indexOf(this), 1)[0];
        if (removed.breadCrumbs.length > 30 &&
            runGreaterThanOdds(0.1)) {
          if (runGreaterThanOdds(0.8)) {
            agents.push(new Agent(removed.breadCrumbs));
          } else {
            agents.push(new Agent(removed.breadCrumbs.reverse()));
          }
        }
      };

  };

  var canvas = document.getElementById('world');
  canvas.width = width;
  canvas.height = height;

  var context = canvas.getContext('2d');

  // Populate an initial boid set
  var boids = [];
  boids.push(new Boid(
    width/2,
    height/2,
    90 * oneDegree));

  var agents = [];


  // Interval operation to prune monitored data
  var data;
  var drawInterval = setInterval(function () {
    data = context.getImageData(0, 0, width, height).data;

    // For each boid, we should run their update operation
    for (var i = 0; i < boids.length; i++) {
      var boid = boids[i];
      boid.update();
      boid.drawLastPath();

      // And, stochastically, generate new spurs
      if (shouldCreateSpur(boid, boids)) {
        var leftOrRightTurn = runGreaterThanOdds(0.5) ? 90 : -90;
        var angleVarianceBase = 0.975
        var angleVariance = angleVarianceBase + (Math.random() * (1 - angleVarianceBase));
        var newBoidAngle = (
          angleVariance *  leftOrRightTurn * oneDegree + boid.angle);

        var carryOverCrumbs = [];
        if (runGreaterThanOdds(shouldCreateSpurOdds - 0.25)) {
          carryOverCrumbs = boid.breadCrumbs;
        }
        boids.push(new Boid(boid.x, boid.y, newBoidAngle, carryOverCrumbs));
      }
    }

  }, 1);

  setTimeout(function () {
    clearInterval(drawInterval);

    var agentDrawInterval = setInterval(function () {
      agents.forEach(function (agent) {
        agent.updateDrawnPath();
      });
    }, 75);

    setTimeout(function () {
      clearInterval(agentDrawInterval);
    }, 25000);

  }, 3000);


  ////
  // Utilities

  function runGreaterThanOdds(odds) {
    return Math.random() > odds;
  }

  function shouldCreateSpur(boid, boids) {
    if (boid.dead) {
      return false;
    } else if (boids.length < 2000) {
      if (runGreaterThanOdds(shouldCreateSpurOdds)) {
        shouldCreateSpurOdds = Math.min(1, shouldCreateSpurOdds * (1.000025))
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  }

  function isDrawnOn(context, width, height) {
    var imageData = context.getImageData(0, 0, width, height);
    var data = imageData.data;
    var result = null;
    var counter = 0;
    var last = data.length - 1;
    for (var i = 0; i < data.length; i++) {
      if (i === last && counter !== 0 && counter === last) {
        result = false;
        break;
      } else if (data[i] !== 0 && data[i] > 0) {
        result = true;
        break;
      } else {
        counter++;
        continue;
      }
    }
    return result;
  }

</script>
